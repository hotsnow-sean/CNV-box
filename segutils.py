import math
from functools import reduce

import numpy as np
import pywt
import rpy2.robjects as robjects
from skimage.restoration import denoise_wavelet


def denoise(data, wavelet):
    levels = 5
    WC = pywt.wavedec(data, wavelet, level=levels, mode="constant")
    noiseSigma = (1 / 0.6745) * np.median(np.abs(WC[-1]))
    threshold = noiseSigma * math.sqrt(2 * math.log(data.shape[0]))
    NWC = list(map(lambda x: pywt.threshold(x, threshold, mode="garrote"), WC))
    return pywt.waverec(NWC, wavelet, mode="constant")[: len(data)]


def no_seg(RD: np.ndarray, pos: np.ndarray, bin_size: int):
    seg_rd = RD.copy()
    seg_start: np.ndarray = pos * bin_size + 1
    seg_end: np.ndarray = seg_start + bin_size - 1

    need_pos = []
    for i in range(1, len(seg_rd) - 1):
        tmp = seg_start[i] - seg_end[i - 1]
        if tmp > 1:
            need_pos.append(i)
    new_len = len(need_pos) + len(seg_rd)
    new_rd = np.empty(new_len)
    new_start = np.full(new_len, 0)
    new_end = np.full(new_len, 0)
    should, cur = 0, 0
    for i in need_pos:
        if i > should:
            tmp = i - should
            new_rd[cur : cur + tmp] = seg_rd[should:i]
            new_start[cur : cur + tmp] = seg_start[should:i]
            new_end[cur : cur + tmp] = seg_end[should:i]
            cur += tmp
            should = i
        new_rd[cur] = (seg_rd[should - 1] + seg_rd[should]) / 2
        new_start[cur] = seg_end[should - 1] + 1
        new_end[cur] = seg_start[should] - 1
        cur += 1
    if len(seg_rd) > should:
        new_rd[cur:] = seg_rd[should:]
        new_start[cur:] = seg_start[should:]
        new_end[cur:] = seg_end[should:]

    return new_rd, new_start, new_end


def cbs_seg(RD: np.ndarray, pos: np.ndarray, bin_size: int):
    from cbseg import segment

    seg_index = segment(RD, shuffles=1000, p=0.05)

    seg_rd = np.empty(len(seg_index))
    seg_start = np.empty(len(seg_index), dtype=int)
    seg_end = np.empty(len(seg_index), dtype=int)

    for i, id in enumerate(seg_index):
        start = id.start
        end = id.end
        seg = RD[start:end]
        seg_rd[i] = np.mean(seg)
        seg_start[i] = pos[start] * bin_size + 1
        seg_end[i] = pos[end - 1] * bin_size + bin_size

    return seg_rd, seg_start, seg_end


def cbs_50_seg(RD: np.ndarray, pos: np.ndarray, bin_size: int):
    from cbseg import segment

    seg_index = []
    for rr in np.split(RD, np.linspace(0, len(RD), 50, dtype=int, endpoint=False)[1:]):
        seg_index.append(segment(rr, shuffles=1000, p=0.05))

    seg_num = reduce(lambda n, s: n + len(s), seg_index, 0)

    seg_rd = np.empty(seg_num)
    seg_start = np.empty(seg_num, dtype=int)
    seg_end = np.empty(seg_num, dtype=int)

    last_num = 0
    i = 0
    for sub_index in seg_index:
        for id in sub_index:
            start = id.start + last_num
            end = id.end + last_num
            seg = RD[start:end]
            seg_rd[i] = np.mean(seg)
            seg_start[i] = pos[start] * bin_size + 1
            seg_end[i] = pos[end - 1] * bin_size + bin_size
            i += 1
        last_num += sub_index.last

    return seg_rd, seg_start, seg_end


def read_seg_file(segpath, num_col, num_bin):
    """
    read segment file (Generated by DNAcopy.segment)
    seg file: col, chr, start, end, num_mark, seg_mean
    """
    seg_start = []
    seg_end = []
    seg_count = []
    seg_len = []
    with open(segpath, "r") as f:
        for line in f:
            linestrlist = line.strip().split("\t")
            start = (int(linestrlist[0]) - 1) * num_col + int(linestrlist[2]) - 1
            end = (int(linestrlist[0]) - 1) * num_col + int(linestrlist[3]) - 1
            if start == end:
                seg_end[-1] += 1
                continue
            if start < num_bin:
                if end > num_bin:
                    end = num_bin - 1
                seg_start.append(start)
                seg_end.append(end)
                seg_count.append(float(linestrlist[5]))
                seg_len.append(int(linestrlist[4]))
    seg_start = np.array(seg_start)
    seg_end = np.array(seg_end)

    return seg_start, seg_end, seg_count, seg_len


def cbs_r_seg(RD: np.ndarray, pos: np.ndarray, bin_size: int, ncol=50):
    """Execute CBS program through R language"""
    seg_path = "./tmpsegment"
    bin_num = len(RD)

    v = robjects.FloatVector(RD)
    m = robjects.r["matrix"](v, ncol=ncol)
    robjects.r.source("CBS_data.R")
    robjects.r.CBS_data(m, seg_path)

    num_col = int(bin_num / ncol) + 1
    s_start, s_end, seg_count, seg_len = read_seg_file(seg_path, num_col, bin_num)

    s_start = s_start[:-1]
    s_end = s_end[:-1]

    seg_rd = np.empty(len(s_start))
    seg_start = np.empty(len(s_start), dtype=int)
    seg_end = np.empty(len(s_start), dtype=int)

    for i, id in enumerate(zip(s_start, s_end)):
        start = id[0]
        end = id[1]
        seg = RD[start:end]
        seg_rd[i] = np.mean(seg)
        seg_start[i] = pos[start] * bin_size + 1
        seg_end[i] = pos[end - 1] * bin_size + bin_size

    return seg_rd, seg_start, seg_end


def wave_seg(RD: np.ndarray, pos: np.ndarray, bin_size: int):
    # newrd = denoise(RD, "haar")
    newrd = denoise_wavelet(RD, method="VisuShrink")
    newrd = newrd[: len(pos)]

    return no_seg(newrd, pos, bin_size)


def wave_cbs_seg(RD: np.ndarray, pos: np.ndarray, bin_size: int):
    nrd = denoise_wavelet(RD, method="VisuShrink", wavelet_levels=2)
    return cbs_seg(nrd[: len(pos)], pos, bin_size)


def wave_cbs_r_seg(RD: np.ndarray, pos: np.ndarray, bin_size: int):
    nrd = denoise_wavelet(RD, method="VisuShrink", wavelet_levels=2)
    return cbs_r_seg(nrd[: len(pos)], pos, bin_size)


def segment(RD: np.ndarray, pos: np.ndarray, bin_size: int, method: str = "cbs"):
    if method == "cbs":
        return cbs_seg(RD, pos, bin_size)
    elif method == "cbs_r":
        return cbs_r_seg(RD, pos, bin_size)
    elif method == "cbs_50":
        return cbs_50_seg(RD, pos, bin_size)
    elif method == "wave":
        return wave_seg(RD, pos, bin_size)
    elif method == "wave_cbs":
        return wave_cbs_seg(RD, pos, bin_size)
    elif method == "wave_cbs_r":
        return wave_cbs_r_seg(RD, pos, bin_size)
    else:
        return no_seg(RD, pos, bin_size)

